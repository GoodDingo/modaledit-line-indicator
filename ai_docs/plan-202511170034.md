# Plan: Fix Mode Detection Bug & Add Comprehensive Testing

**Created:** 2025-11-17 00:34
**Status:** Ready for execution
**Priority:** Critical (mode detection is broken)

---

## Executive Summary

**Problem:** The ModalEdit Line Indicator extension decorates lines correctly BUT always shows insert mode color (red). The color never changes to normal mode (green) even when ModalEdit is in normal mode and cursor moves.

**Root Cause:** Mode detection is broken. The `isInNormalMode()` method consistently returns `false`, indicating that `vscode.commands.executeCommand('getContext', 'modaledit.normal')` is not working as expected.

**Solution:**
1. Debug to find exact cause of mode detection failure
2. Fix the mode detection mechanism
3. Add comprehensive automated tests (behavioral)
4. Create manual testing checklist (visual verification)
5. Document testing limitations and procedures

---

## Part 1: Investigation & Root Cause Analysis

### 1.1 Understanding the Current Behavior

**What Works:**
- ✅ Extension activates successfully
- ✅ Decorations are applied to current line
- ✅ Decorations follow cursor movements
- ✅ Multi-line wrapped text is fully highlighted (good behavior)
- ✅ Configuration is read correctly
- ✅ Event listeners are registered

**What's Broken:**
- ❌ Mode detection always returns `false` (insert mode)
- ❌ Color never changes from red to green
- ❌ Context query `getContext('modaledit.normal')` is not working

### 1.2 Hypotheses for Mode Detection Failure

**Hypothesis 1: Wrong Context Key Name**
- Our code queries `'modaledit.normal'`
- ModalEdit might use a different key name
- **Action:** Investigate ModalEdit source to find exact context key

**Hypothesis 2: Context Not Set by ModalEdit**
- ModalEdit version might not set the context key
- Context key API might have changed
- **Action:** Check ModalEdit version and API

**Hypothesis 3: Timing/Race Condition**
- Extension queries before ModalEdit sets context
- Context query happens too early in lifecycle
- **Action:** Add retry mechanism or delayed query

**Hypothesis 4: Context Query API Issue**
- `executeCommand('getContext', ...)` might not work as expected
- VS Code API might have changed
- **Action:** Test alternative context query methods

**Hypothesis 5: ModalEdit Extension Not Fully Activated**
- ModalEdit installed but not activated when we query
- **Action:** Check ModalEdit activation state before querying

### 1.3 Debug Investigation Steps

**Step 1: Add comprehensive logging**
- Log the exact return value from `executeCommand('getContext', 'modaledit.normal')`
- Log whether we're hitting the catch block
- Log ModalEdit extension presence and activation state
- Log every mode check attempt with timestamp

**Step 2: Verify ModalEdit context key**
- Read ModalEdit source code at `/Users/mira.hedl/LEARN/GIT/github.com/johtela/vscode-modaledit/src/`
- Find where ModalEdit calls `setContext`
- Verify the exact context key name used
- Check ModalEdit documentation for context key info

**Step 3: Test context query manually**
- Add debug command to query context on-demand
- Test if context can be set/queried manually
- Verify VS Code context system is working

**Step 4: Check ModalEdit activation**
- Verify ModalEdit extension is installed
- Check if ModalEdit is activated before our query
- Test activation order dependencies

---

## Part 2: Bug Fix Implementation

### 2.1 Add Debug Logging Infrastructure

**File:** `src/extension.ts`

**Changes needed:**
1. Add verbose logging configuration
2. Log context query attempts and results
3. Log ModalEdit extension state
4. Add timing information to all logs

**Implementation:**
```typescript
// Add debug flag
private readonly DEBUG = true; // TODO: Make configurable

// Enhanced logging in isInNormalMode()
private async isInNormalMode(): Promise<boolean> {
  try {
    if (this.DEBUG) {
      console.log('[ModalEdit Line Indicator] Querying mode context...');
    }

    const contextValue = await vscode.commands.executeCommand('getContext', 'modaledit.normal');

    if (this.DEBUG) {
      console.log('[ModalEdit Line Indicator] Context value:', contextValue, 'Type:', typeof contextValue);
    }

    const isNormal = contextValue === true;

    if (this.DEBUG) {
      console.log('[ModalEdit Line Indicator] Mode detected:', isNormal ? 'NORMAL' : 'INSERT');
    }

    return isNormal;
  } catch (error) {
    console.error('[ModalEdit Line Indicator] Mode detection error:', error);
    return false;
  }
}

// Add ModalEdit detection in activate()
public async activate(): Promise<void> {
  console.log('[ModalEdit Line Indicator] Activating...');

  // Check if ModalEdit is installed
  const modalEditExt = vscode.extensions.getExtension('johtela.vscode-modaledit');
  if (modalEditExt) {
    console.log('[ModalEdit Line Indicator] ModalEdit extension found, version:', modalEditExt.packageJSON.version);
    console.log('[ModalEdit Line Indicator] ModalEdit active:', modalEditExt.isActive);

    if (!modalEditExt.isActive) {
      console.log('[ModalEdit Line Indicator] Waiting for ModalEdit to activate...');
      await modalEditExt.activate();
    }
  } else {
    console.warn('[ModalEdit Line Indicator] ModalEdit extension NOT found!');
  }

  // ... rest of activation
}
```

### 2.2 Add Debug Command for Manual Mode Checking

**File:** `src/extension.ts` + `package.json`

**New command:** `modaledit-line-indicator.checkMode`

**Implementation:**
```typescript
// In registerListeners()
this.disposables.push(
  vscode.commands.registerCommand('modaledit-line-indicator.checkMode', async () => {
    const isNormal = await this.isInNormalMode();
    const mode = isNormal ? 'NORMAL (green)' : 'INSERT (red)';

    // Also check ModalEdit directly
    const modalEditExt = vscode.extensions.getExtension('johtela.vscode-modaledit');
    const modalEditStatus = modalEditExt
      ? `ModalEdit installed (v${modalEditExt.packageJSON.version}, active: ${modalEditExt.isActive})`
      : 'ModalEdit NOT installed';

    vscode.window.showInformationMessage(
      `Mode: ${mode} | ${modalEditStatus}`
    );
  })
);
```

**Add to package.json:**
```json
{
  "command": "modaledit-line-indicator.checkMode",
  "title": "ModalEdit Line Indicator: Check Current Mode"
}
```

### 2.3 Investigate ModalEdit Context Key

**Action:** Manually search ModalEdit source for context key usage

**Files to check:**
- `/Users/mira.hedl/LEARN/GIT/github.com/johtela/vscode-modaledit/src/commands.ts`
- `/Users/mira.hedl/LEARN/GIT/github.com/johtela/vscode-modaledit/src/actions.ts`
- `/Users/mira.hedl/LEARN/GIT/github.com/johtela/vscode-modaledit/src/extension.ts`

**Search for:**
- `setContext`
- `modaledit.normal`
- Context key definitions

**Expected findings:**
- Exact context key name
- When/where it's set
- What values it can have

### 2.4 Fix Based on Findings

**Scenario A: Context key name is different**
```typescript
// Change from 'modaledit.normal' to correct key
return (await vscode.commands.executeCommand('getContext', 'correctKeyName')) === true;
```

**Scenario B: Context not set by ModalEdit**
```typescript
// Implement alternative detection method
// Option 1: Check ModalEdit's exported API
const modalEditExt = vscode.extensions.getExtension('johtela.vscode-modaledit');
if (modalEditExt?.exports?.getCurrentMode) {
  return modalEditExt.exports.getCurrentMode() === 'normal';
}

// Option 2: Listen to ModalEdit commands
// Track when enterNormal/enterInsert commands are executed
```

**Scenario C: Timing issue**
```typescript
// Add retry mechanism with delay
private async isInNormalMode(): Promise<boolean> {
  let retries = 3;
  while (retries > 0) {
    try {
      const result = await vscode.commands.executeCommand('getContext', 'modaledit.normal');
      if (result !== undefined) {
        return result === true;
      }
    } catch (error) {
      // Retry
    }
    retries--;
    await new Promise(resolve => setTimeout(resolve, 100));
  }
  return false; // Default after retries exhausted
}
```

**Scenario D: Need to wait for ModalEdit**
```typescript
// Ensure ModalEdit is activated before querying
public async activate(): Promise<void> {
  const modalEditExt = vscode.extensions.getExtension('johtela.vscode-modaledit');
  if (modalEditExt && !modalEditExt.isActive) {
    await modalEditExt.activate();
    // Wait a bit for context to be set
    await new Promise(resolve => setTimeout(resolve, 200));
  }

  // ... rest of activation
}
```

### 2.5 Add Fallback Mode Detection

**Implementation:** Multiple detection strategies

```typescript
private async isInNormalMode(): Promise<boolean> {
  // Strategy 1: Context key (primary)
  try {
    const contextValue = await vscode.commands.executeCommand('getContext', 'modaledit.normal');
    if (contextValue !== undefined) {
      return contextValue === true;
    }
  } catch (error) {
    console.log('[ModalEdit Line Indicator] Context query failed:', error);
  }

  // Strategy 2: ModalEdit API (if available)
  try {
    const modalEditExt = vscode.extensions.getExtension('johtela.vscode-modaledit');
    if (modalEditExt?.isActive && modalEditExt.exports?.getCurrentMode) {
      return modalEditExt.exports.getCurrentMode() === 'normal';
    }
  } catch (error) {
    console.log('[ModalEdit Line Indicator] API query failed:', error);
  }

  // Strategy 3: Default to insert mode
  return false;
}
```

---

## Part 3: Automated Testing (Behavioral)

### 3.1 Testing Philosophy

**What we CAN test:**
- Logic execution (does code run without errors?)
- State changes (does internal state update correctly?)
- Event handling (are events triggered and handled?)
- Configuration (are settings read and applied?)
- Error handling (do errors get caught gracefully?)

**What we CANNOT test:**
- Visual appearance (what colors are displayed?)
- Decoration rendering (are decorations visible?)
- UI verification (does it look correct?)

**Approach:** Test all behavioral aspects thoroughly, document visual testing separately.

### 3.2 Test Structure

**Test files to create:**

```
src/test/suite/
├── extension.test.ts           # Existing - update
├── modeDetection.test.ts       # NEW - Mode detection logic
├── decorationLifecycle.test.ts # NEW - Decoration management
├── eventHandling.test.ts       # NEW - Event listener behavior
├── configuration.test.ts       # NEW - Config management
├── modalEditIntegration.test.ts # NEW - Integration with ModalEdit
└── helpers/
    └── testHelpers.ts          # NEW - Test utilities
```

### 3.3 Test Implementation Details

#### Test File 1: `modeDetection.test.ts`

**Purpose:** Test mode detection logic in isolation

**Tests:**
1. **Test context query returns correct value**
   - Set context to `true`, verify `isInNormalMode()` returns `true`
   - Set context to `false`, verify `isInNormalMode()` returns `false`
   - Context `undefined`, verify `isInNormalMode()` returns `false`

2. **Test ModalEdit presence detection**
   - Verify extension can detect if ModalEdit is installed
   - Verify extension can check if ModalEdit is activated
   - Verify graceful handling when ModalEdit is missing

3. **Test error handling**
   - Context query throws error → should catch and return `false`
   - No active editor → should not crash
   - Multiple rapid queries → should handle debouncing

**Example test:**
```typescript
suite('Mode Detection Tests', () => {
  test('Returns true when context is true', async () => {
    // Note: This requires ModalEdit to be installed and in normal mode
    // If ModalEdit is not installed, test will be skipped

    const modalEditExt = vscode.extensions.getExtension('johtela.vscode-modaledit');
    if (!modalEditExt) {
      console.log('Skipping test - ModalEdit not installed');
      return;
    }

    await modalEditExt.activate();

    // Try to set context (may not work, depends on ModalEdit API)
    const contextValue = await vscode.commands.executeCommand('getContext', 'modaledit.normal');

    // Just verify we can query it without errors
    assert.notStrictEqual(contextValue, undefined, 'Context should be defined when ModalEdit is active');
  });

  test('Handles missing ModalEdit gracefully', async () => {
    // This test verifies the extension doesn't crash when ModalEdit is missing
    // We can't uninstall ModalEdit programmatically, so we test error handling

    const ext = vscode.extensions.getExtension('user.modaledit-line-indicator');
    assert.ok(ext, 'Extension should be installed');

    await ext.activate();

    // Extension should be active even if ModalEdit is missing
    assert.strictEqual(ext.isActive, true, 'Extension should activate without ModalEdit');
  });
});
```

#### Test File 2: `decorationLifecycle.test.ts`

**Purpose:** Test decoration creation, application, and disposal

**Tests:**
1. **Test decoration creation**
   - Verify decorations can be created without errors
   - Verify both normal and insert decorations exist
   - Verify decorations have correct configuration

2. **Test decoration application**
   - Verify decorations can be applied to editor
   - Verify only one decoration active at a time
   - Verify inactive decoration is cleared

3. **Test decoration disposal**
   - Verify decorations disposed on deactivation
   - Verify decorations disposed on config change
   - Verify no memory leaks

**Example test:**
```typescript
suite('Decoration Lifecycle Tests', () => {
  test('Can create decorations without errors', () => {
    const normalDecoration = vscode.window.createTextEditorDecorationType({
      backgroundColor: 'rgba(0, 255, 0, 0.3)',
      border: '2px solid green',
      isWholeLine: true
    });

    const insertDecoration = vscode.window.createTextEditorDecorationType({
      backgroundColor: 'rgba(255, 0, 0, 0.3)',
      border: '2px solid red',
      isWholeLine: true
    });

    assert.ok(normalDecoration, 'Normal decoration should be created');
    assert.ok(insertDecoration, 'Insert decoration should be created');

    // Clean up
    normalDecoration.dispose();
    insertDecoration.dispose();
  });

  test('Can apply decorations to editor', async () => {
    const doc = await vscode.workspace.openTextDocument({ content: 'line1\nline2\nline3' });
    const editor = await vscode.window.showTextDocument(doc);

    const decoration = vscode.window.createTextEditorDecorationType({
      backgroundColor: 'rgba(0, 255, 0, 0.3)'
    });

    // Apply decoration - should not throw
    assert.doesNotThrow(() => {
      editor.setDecorations(decoration, [new vscode.Range(0, 0, 0, 0)]);
    });

    // Clear decoration
    editor.setDecorations(decoration, []);
    decoration.dispose();

    await vscode.commands.executeCommand('workbench.action.closeActiveEditor');
  });

  test('Decorations are disposed on deactivation', async () => {
    const ext = vscode.extensions.getExtension('user.modaledit-line-indicator');
    assert.ok(ext);

    if (!ext.isActive) {
      await ext.activate();
    }

    // Deactivate by reloading window (in real scenario)
    // For test, just verify extension was active
    assert.strictEqual(ext.isActive, true);

    // Note: Can't actually test disposal in same test run
    // Would need to reload VS Code window
  });
});
```

#### Test File 3: `eventHandling.test.ts`

**Purpose:** Test event listeners trigger correct behavior

**Tests:**
1. **Test selection change event**
   - Change selection → verify update is triggered
   - Move cursor → verify highlight follows
   - Rapid changes → verify debouncing works

2. **Test editor switch event**
   - Switch between editors → verify highlight updates
   - Close all editors → verify no errors
   - Open new editor → verify highlight appears

3. **Test configuration change event**
   - Change color → verify decorations reloaded
   - Change border → verify update occurs
   - Toggle enabled → verify extension respects setting

**Example test:**
```typescript
suite('Event Handling Tests', () => {
  test('Selection change triggers update', async () => {
    const doc = await vscode.workspace.openTextDocument({ content: 'line1\nline2\nline3' });
    const editor = await vscode.window.showTextDocument(doc);

    // Change selection
    const newPosition = new vscode.Position(1, 0);
    editor.selection = new vscode.Selection(newPosition, newPosition);

    // Wait for debounce (10ms) + buffer
    await new Promise(resolve => setTimeout(resolve, 50));

    // Can't verify decoration, but can verify no errors occurred
    assert.ok(editor.selection.active.line === 1, 'Cursor should be on line 1');
  });

  test('Configuration change triggers reload', async () => {
    const config = vscode.workspace.getConfiguration('modaledit-line-indicator');
    const originalColor = config.get('normalModeBackground');

    // Change configuration
    await config.update('normalModeBackground', '#ff0000', vscode.ConfigurationTarget.Global);

    // Wait for config change event
    await new Promise(resolve => setTimeout(resolve, 200));

    // Verify config changed
    const newConfig = vscode.workspace.getConfiguration('modaledit-line-indicator');
    assert.strictEqual(newConfig.get('normalModeBackground'), '#ff0000');

    // Restore original
    await config.update('normalModeBackground', originalColor, vscode.ConfigurationTarget.Global);
  });

  test('Debouncing prevents excessive updates', async () => {
    const doc = await vscode.workspace.openTextDocument({ content: 'line1\nline2\nline3\nline4\nline5' });
    const editor = await vscode.window.showTextDocument(doc);

    // Rapid selection changes
    for (let i = 0; i < 5; i++) {
      editor.selection = new vscode.Selection(new vscode.Position(i, 0), new vscode.Position(i, 0));
      // Don't wait - rapid changes
    }

    // Wait for debounce to settle
    await new Promise(resolve => setTimeout(resolve, 50));

    // Should have only updated once (after debounce)
    // Can't verify count, but verify no crash
    assert.ok(editor.selection.active.line === 4, 'Final position should be line 4');

    await vscode.commands.executeCommand('workbench.action.closeActiveEditor');
  });
});
```

#### Test File 4: `configuration.test.ts`

**Purpose:** Test configuration management

**Tests:**
1. **Test default values**
   - Verify all defaults are correct
   - Verify defaults match package.json schema

2. **Test configuration updates**
   - Update each config value
   - Verify extension reads new values
   - Verify decorations are recreated

3. **Test enabled/disabled state**
   - Disable extension → decorations cleared
   - Enable extension → decorations applied
   - Toggle multiple times → no errors

**Example test:**
```typescript
suite('Configuration Tests', () => {
  test('Default configuration values are correct', () => {
    const config = vscode.workspace.getConfiguration('modaledit-line-indicator');

    assert.strictEqual(config.get('enabled'), true, 'Default enabled should be true');
    assert.strictEqual(config.get('normalModeBackground'), 'rgba(0, 255, 0, 0.3)');
    assert.strictEqual(config.get('insertModeBackground'), 'rgba(255, 0, 0, 0.3)');
    assert.strictEqual(config.get('borderStyle'), 'solid');
    assert.strictEqual(config.get('borderWidth'), '2px');
  });

  test('Can update all configuration values', async () => {
    const config = vscode.workspace.getConfiguration('modaledit-line-indicator');

    const updates = {
      'enabled': false,
      'normalModeBackground': '#123456',
      'normalModeBorder': '#654321',
      'insertModeBackground': '#abcdef',
      'insertModeBorder': '#fedcba',
      'borderStyle': 'dashed',
      'borderWidth': '5px'
    };

    // Store originals
    const originals: any = {};
    for (const key of Object.keys(updates)) {
      originals[key] = config.get(key);
    }

    // Update all
    for (const [key, value] of Object.entries(updates)) {
      await config.update(key, value, vscode.ConfigurationTarget.Global);
    }

    // Wait for updates to propagate
    await new Promise(resolve => setTimeout(resolve, 200));

    // Verify
    const updatedConfig = vscode.workspace.getConfiguration('modaledit-line-indicator');
    for (const [key, value] of Object.entries(updates)) {
      assert.strictEqual(updatedConfig.get(key), value, `${key} should be updated`);
    }

    // Restore originals
    for (const [key, value] of Object.entries(originals)) {
      await config.update(key, value, vscode.ConfigurationTarget.Global);
    }
  });
});
```

#### Test File 5: `modalEditIntegration.test.ts`

**Purpose:** Test integration with ModalEdit extension

**Tests:**
1. **Test ModalEdit detection**
   - Verify can detect if ModalEdit is installed
   - Verify can check activation state
   - Skip tests gracefully if not available

2. **Test context key integration**
   - Query `modaledit.normal` context
   - Verify context exists and has boolean value
   - Test both normal and insert modes (if possible)

3. **Test without ModalEdit**
   - Verify extension works without ModalEdit
   - Verify defaults to insert mode
   - Verify no crashes or errors

**Example test:**
```typescript
suite('ModalEdit Integration Tests', () => {
  test('Can detect ModalEdit extension', () => {
    const modalEditExt = vscode.extensions.getExtension('johtela.vscode-modaledit');

    if (modalEditExt) {
      console.log('ModalEdit found - version:', modalEditExt.packageJSON.version);
      console.log('ModalEdit active:', modalEditExt.isActive);
    } else {
      console.log('ModalEdit not installed - skipping integration tests');
    }

    // Test passes either way - just informational
    assert.ok(true);
  });

  test('Can query ModalEdit context (if installed)', async () => {
    const modalEditExt = vscode.extensions.getExtension('johtela.vscode-modaledit');

    if (!modalEditExt) {
      console.log('Skipping - ModalEdit not installed');
      return;
    }

    // Ensure ModalEdit is activated
    if (!modalEditExt.isActive) {
      await modalEditExt.activate();
    }

    // Query context
    const contextValue = await vscode.commands.executeCommand('getContext', 'modaledit.normal');

    console.log('Context value:', contextValue, 'Type:', typeof contextValue);

    // Should be boolean or undefined
    assert.ok(
      typeof contextValue === 'boolean' || contextValue === undefined,
      'Context should be boolean or undefined'
    );
  });

  test('Extension works without ModalEdit', async () => {
    const ext = vscode.extensions.getExtension('user.modaledit-line-indicator');
    assert.ok(ext, 'Extension should be installed');

    if (!ext.isActive) {
      await ext.activate();
    }

    // Should activate successfully even without ModalEdit
    assert.strictEqual(ext.isActive, true, 'Extension should be active');

    // Should default to insert mode (false)
    // Can't test this directly, but verify no crashes

    const doc = await vscode.workspace.openTextDocument({ content: 'test' });
    const editor = await vscode.window.showTextDocument(doc);

    // Should not crash when opening editor
    assert.ok(editor, 'Editor should open successfully');

    await vscode.commands.executeCommand('workbench.action.closeActiveEditor');
  });
});
```

#### Test Helpers: `helpers/testHelpers.ts`

**Purpose:** Common test utilities

```typescript
import * as vscode from 'vscode';

export class TestHelpers {
  /**
   * Create a test document with specified content
   */
  static async createTestDocument(content: string): Promise<vscode.TextDocument> {
    return await vscode.workspace.openTextDocument({ content });
  }

  /**
   * Open document in editor
   */
  static async openInEditor(doc: vscode.TextDocument): Promise<vscode.TextEditor> {
    return await vscode.window.showTextDocument(doc);
  }

  /**
   * Create test document and open in editor (combo)
   */
  static async createTestEditor(content: string): Promise<vscode.TextEditor> {
    const doc = await this.createTestDocument(content);
    return await this.openInEditor(doc);
  }

  /**
   * Close all open editors
   */
  static async closeAllEditors(): Promise<void> {
    await vscode.commands.executeCommand('workbench.action.closeAllEditors');
  }

  /**
   * Wait for debounce to settle
   */
  static async waitForDebounce(ms: number = 50): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Get ModalEdit extension if installed
   */
  static getModalEditExtension(): vscode.Extension<any> | undefined {
    return vscode.extensions.getExtension('johtela.vscode-modaledit');
  }

  /**
   * Check if ModalEdit is available and activated
   */
  static async ensureModalEditActive(): Promise<boolean> {
    const modalEditExt = this.getModalEditExtension();

    if (!modalEditExt) {
      return false;
    }

    if (!modalEditExt.isActive) {
      await modalEditExt.activate();
    }

    return modalEditExt.isActive;
  }

  /**
   * Query ModalEdit context value
   */
  static async getModalEditContext(): Promise<boolean | undefined> {
    try {
      return await vscode.commands.executeCommand('getContext', 'modaledit.normal') as boolean | undefined;
    } catch {
      return undefined;
    }
  }

  /**
   * Get extension configuration
   */
  static getConfig(): vscode.WorkspaceConfiguration {
    return vscode.workspace.getConfiguration('modaledit-line-indicator');
  }

  /**
   * Reset configuration to defaults
   */
  static async resetConfig(): Promise<void> {
    const config = this.getConfig();
    const keys = [
      'enabled',
      'normalModeBackground',
      'normalModeBorder',
      'insertModeBackground',
      'insertModeBorder',
      'borderStyle',
      'borderWidth'
    ];

    for (const key of keys) {
      await config.update(key, undefined, vscode.ConfigurationTarget.Global);
    }
  }
}
```

### 3.4 Test Coverage Goals

**Target coverage:** 80%+ for all source files

**Coverage configuration:** (already set up in package.json)
```json
{
  "coverage": "c8 npm run test:unit",
  "test:unit": "node ./out/test/runTest.js"
}
```

**Run coverage:**
```bash
make coverage
```

**View reports:**
- Text: Terminal output
- HTML: `coverage/index.html`

---

## Part 4: Manual Testing (Visual Verification)

### 4.1 Why Manual Testing is Required

**Fundamental limitation:** VS Code Extension API does NOT provide methods to:
- Query what decorations are applied to an editor
- Inspect decoration styles (colors, borders, backgrounds)
- Verify visual rendering of decorations
- Check if decorations are actually visible

**Therefore:** Visual appearance MUST be verified manually by human observation.

### 4.2 Manual Testing Checklist

**File:** `ai_docs/MANUAL-TESTING.md`

**Contents:**

```markdown
# Manual Testing Checklist for ModalEdit Line Indicator

## Prerequisites

- [ ] VS Code installed (version 1.106.0+)
- [ ] ModalEdit extension installed
- [ ] ModalEdit Line Indicator extension installed (dev build)
- [ ] ModalEdit keybindings configured (Escape for normal, i for insert)

## Setup Verification

1. Open VS Code
2. Open a test file (any text file)
3. Open Debug Console (Cmd/Ctrl + Shift + Y)
4. Look for activation messages:
   - `[ModalEdit Line Indicator] Activating...`
   - `[ModalEdit Line Indicator] ModalEdit extension found`
   - `[ModalEdit Line Indicator] Activated`

## Test 1: Basic Mode Detection

### Normal Mode
- [ ] Press Escape to enter normal mode
- [ ] **Verify:** Line highlight is GREEN
- [ ] **Verify:** Border is green (solid 2px by default)
- [ ] Move cursor up/down with j/k or arrows
- [ ] **Verify:** Green highlight follows cursor

### Insert Mode
- [ ] Press `i` to enter insert mode
- [ ] **Verify:** Line highlight is RED
- [ ] **Verify:** Border is red (solid 2px by default)
- [ ] Type some text
- [ ] **Verify:** Red highlight follows cursor while typing
- [ ] Move cursor with arrow keys
- [ ] **Verify:** Red highlight follows cursor

## Test 2: Mode Switching

- [ ] Start in insert mode (red highlight visible)
- [ ] Press Escape → **Verify:** Immediate change to green
- [ ] Press `i` → **Verify:** Immediate change to red
- [ ] Rapidly switch modes (Escape, i, Escape, i, ...)
- [ ] **Verify:** Smooth color changes, no flicker, no lag

## Test 3: Multi-line Wrapped Text

- [ ] Resize VS Code window to be narrow
- [ ] Type a very long line that wraps to 2-3 visual lines
- [ ] **Verify:** All wrapped portions are highlighted
- [ ] Switch modes
- [ ] **Verify:** All wrapped portions change color together

## Test 4: Multiple Editors

- [ ] Open two files side by side (split editor)
- [ ] Set left editor to normal mode (green)
- [ ] Set right editor to insert mode (red)
- [ ] Click between editors
- [ ] **Verify:** Each editor maintains its own highlight color
- [ ] **Verify:** Active editor's highlight is visible
- [ ] Close one editor
- [ ] **Verify:** Remaining editor still has correct highlight

## Test 5: Configuration Changes

### Change Normal Mode Color
- [ ] Open Settings (Cmd/Ctrl + ,)
- [ ] Search for "modaledit-line-indicator.normalModeBackground"
- [ ] Change to different color (e.g., `rgba(0, 0, 255, 0.3)` for blue)
- [ ] **Verify:** Green highlight immediately changes to blue
- [ ] No reload required

### Change Insert Mode Color
- [ ] Change "modaledit-line-indicator.insertModeBackground" to `rgba(255, 255, 0, 0.3)` (yellow)
- [ ] Switch to insert mode
- [ ] **Verify:** Red highlight is now yellow

### Change Border Style
- [ ] Change "modaledit-line-indicator.borderStyle" to "dashed"
- [ ] **Verify:** Border becomes dashed
- [ ] Try "dotted"
- [ ] **Verify:** Border becomes dotted

### Change Border Width
- [ ] Change "modaledit-line-indicator.borderWidth" to "5px"
- [ ] **Verify:** Border becomes thicker

### Toggle Enabled/Disabled
- [ ] Change "modaledit-line-indicator.enabled" to `false`
- [ ] **Verify:** All highlights disappear
- [ ] Change back to `true`
- [ ] **Verify:** Highlights reappear with correct color

## Test 6: Edge Cases

### No Active Editor
- [ ] Close all editors (Cmd/Ctrl + K, W)
- [ ] **Verify:** No errors in Debug Console
- [ ] Open a new file
- [ ] **Verify:** Highlight appears immediately

### Empty File
- [ ] Create new file (Cmd/Ctrl + N)
- [ ] Don't type anything (empty)
- [ ] **Verify:** Highlight appears on line 1
- [ ] Switch modes
- [ ] **Verify:** Color changes

### Very Long File
- [ ] Open a file with 1000+ lines
- [ ] Scroll to bottom
- [ ] Switch modes
- [ ] **Verify:** No lag, immediate response
- [ ] Move cursor rapidly
- [ ] **Verify:** Smooth highlighting, no performance issues

### Different File Types
- [ ] Test with .txt file → works
- [ ] Test with .js file → works
- [ ] Test with .md file → works
- [ ] Test with .json file → works

## Test 7: Debug Commands

### Check Mode Command
- [ ] Open Command Palette (Cmd/Ctrl + Shift + P)
- [ ] Run: "ModalEdit Line Indicator: Check Current Mode"
- [ ] In normal mode: **Verify** message shows "Mode: NORMAL (green)"
- [ ] In insert mode: **Verify** message shows "Mode: INSERT (red)"
- [ ] **Verify** message shows ModalEdit installation status

### Toggle Enabled Command
- [ ] Open Command Palette
- [ ] Run: "ModalEdit Line Indicator: Toggle Enabled"
- [ ] **Verify:** Highlights disappear and message says "disabled"
- [ ] Run command again
- [ ] **Verify:** Highlights reappear and message says "enabled"

## Test 8: ModalEdit Integration

### With ModalEdit Installed
- [ ] Verify ModalEdit is installed and active
- [ ] Enter normal mode using ModalEdit keybinding
- [ ] **Verify:** Green highlight appears
- [ ] Enter insert mode using ModalEdit keybinding
- [ ] **Verify:** Red highlight appears

### Without ModalEdit (Negative Test)
- [ ] Disable ModalEdit extension
- [ ] Reload VS Code window
- [ ] Open a file
- [ ] **Verify:** Extension still loads (check Debug Console)
- [ ] **Verify:** Red (insert) highlight appears by default
- [ ] **Verify:** No errors in Debug Console
- [ ] Re-enable ModalEdit extension

## Test 9: Theme Compatibility

### Dark Themes
- [ ] Switch to dark theme (e.g., Dark+)
- [ ] **Verify:** Green and red highlights are visible
- [ ] **Verify:** Highlights don't clash with theme colors

### Light Themes
- [ ] Switch to light theme (e.g., Light+)
- [ ] **Verify:** Green and red highlights are visible
- [ ] **Verify:** Highlights are not too dark/light

### High Contrast
- [ ] Switch to high contrast theme
- [ ] **Verify:** Highlights are still visible
- [ ] Adjust opacity if needed

## Test 10: Performance

### Rapid Cursor Movement
- [ ] Hold down `j` or down arrow for 5 seconds
- [ ] **Verify:** No lag, smooth highlighting
- [ ] **Verify:** CPU usage is normal (check Activity Monitor/Task Manager)

### Rapid Mode Switching
- [ ] Rapidly press Escape, i, Escape, i for 10 seconds
- [ ] **Verify:** No flicker, smooth transitions
- [ ] **Verify:** No memory leaks (check over time)

### Many Open Files
- [ ] Open 10+ files
- [ ] Switch between them
- [ ] **Verify:** Each highlights correctly
- [ ] **Verify:** No performance degradation

## Regression Testing

After any code changes, re-run:
- [ ] Test 1: Basic Mode Detection
- [ ] Test 2: Mode Switching
- [ ] Test 5: Configuration Changes
- [ ] Test 7: Debug Commands

## Known Limitations

- Highlight may lag if mode is switched WITHOUT moving cursor (edge case)
- Search mode shows same color as normal mode (ModalEdit limitation)

## Reporting Issues

If any test fails, note:
- VS Code version
- ModalEdit version
- Extension version
- Operating system
- Exact steps to reproduce
- Debug Console output
```

### 4.3 Debug Commands for Manual Testing

**Additional commands to help with visual testing:**

```typescript
// Force normal mode decoration (for testing)
this.disposables.push(
  vscode.commands.registerCommand('modaledit-line-indicator.forceNormalMode', async () => {
    const editor = vscode.window.activeTextEditor;
    if (editor) {
      const ranges = this.getDecorateRanges(editor);
      editor.setDecorations(this.decorations.normal, ranges);
      editor.setDecorations(this.decorations.insert, []);
      vscode.window.showInformationMessage('Forced NORMAL mode decoration (green)');
    }
  })
);

// Force insert mode decoration (for testing)
this.disposables.push(
  vscode.commands.registerCommand('modaledit-line-indicator.forceInsertMode', async () => {
    const editor = vscode.window.activeTextEditor;
    if (editor) {
      const ranges = this.getDecorateRanges(editor);
      editor.setDecorations(this.decorations.insert, ranges);
      editor.setDecorations(this.decorations.normal, []);
      vscode.window.showInformationMessage('Forced INSERT mode decoration (red)');
    }
  })
);
```

Add to package.json:
```json
{
  "command": "modaledit-line-indicator.forceNormalMode",
  "title": "ModalEdit Line Indicator: Force Normal Mode (Debug)"
},
{
  "command": "modaledit-line-indicator.forceInsertMode",
  "title": "ModalEdit Line Indicator: Force Insert Mode (Debug)"
}
```

**Use case:** Compare colors side-by-side without switching modes in ModalEdit.

---

## Part 5: Documentation Updates

### 5.1 Update NEXT-STEPS.md

Add testing status:
- Mark automated testing as complete
- Document what can/cannot be tested
- Reference manual testing checklist
- Update success criteria

### 5.2 Update CLAUDE.md

Add testing section:
- Test infrastructure overview
- Running tests
- Coverage requirements
- Manual testing requirements

### 5.3 Update README.md

Add testing section for users:
- How to verify extension is working
- How to test mode detection
- How to use debug commands
- Troubleshooting guide

### 5.4 Create TESTING.md

Comprehensive testing guide:
- For developers: automated tests
- For users: manual verification
- For CI/CD: test automation
- Coverage requirements

---

## Part 6: Implementation Checklist

### Phase 1: Investigation (1-2 hours)
- [ ] Add debug logging to extension
- [ ] Add checkMode debug command
- [ ] Test in Extension Development Host
- [ ] Check Debug Console output
- [ ] Investigate ModalEdit source code
- [ ] Identify exact context key name
- [ ] Determine root cause of bug

### Phase 2: Bug Fix (1-2 hours)
- [ ] Implement fix based on findings
- [ ] Add ModalEdit activation wait if needed
- [ ] Add retry mechanism if needed
- [ ] Add fallback detection methods
- [ ] Test fix in Extension Development Host
- [ ] Verify colors change with modes
- [ ] Verify wrapped lines work
- [ ] Commit bug fix

### Phase 3: Automated Tests (3-4 hours)
- [ ] Create test helper utilities
- [ ] Write mode detection tests
- [ ] Write decoration lifecycle tests
- [ ] Write event handling tests
- [ ] Write configuration tests
- [ ] Write ModalEdit integration tests
- [ ] Run all tests: `make test`
- [ ] Generate coverage: `make coverage`
- [ ] Verify >80% coverage
- [ ] Commit tests

### Phase 4: Manual Testing (1-2 hours)
- [ ] Create MANUAL-TESTING.md checklist
- [ ] Add force mode debug commands
- [ ] Perform complete manual test
- [ ] Test all scenarios in checklist
- [ ] Document any issues found
- [ ] Fix issues if any
- [ ] Re-test
- [ ] Commit manual testing docs

### Phase 5: Documentation (1 hour)
- [ ] Update NEXT-STEPS.md
- [ ] Update CLAUDE.md testing section
- [ ] Update README.md with testing info
- [ ] Create TESTING.md guide
- [ ] Update package.json commands
- [ ] Commit documentation

### Phase 6: Validation (30 min)
- [ ] Run `make validate` → must pass
- [ ] Run `make test` → all tests pass
- [ ] Run `make coverage` → >80%
- [ ] Manual test all critical scenarios
- [ ] Test in clean VS Code install
- [ ] Verify no console errors
- [ ] Create .vsix package
- [ ] Test .vsix installation

---

## Success Criteria

### Bug Fix Success
- ✅ Extension detects normal mode correctly (green highlight)
- ✅ Extension detects insert mode correctly (red highlight)
- ✅ Colors change immediately when switching modes
- ✅ Colors update after cursor movement
- ✅ No console errors during operation
- ✅ Works with ModalEdit installed and activated
- ✅ Gracefully handles missing ModalEdit

### Testing Success
- ✅ Automated tests achieve >80% code coverage
- ✅ All testable behavior has tests
- ✅ Tests run successfully in CI
- ✅ Manual testing checklist covers all visual aspects
- ✅ Debug commands help with troubleshooting
- ✅ Documentation clearly explains testing approach

### Overall Success
- ✅ Extension works as designed (mode colors correct)
- ✅ Comprehensive test coverage (automated + manual)
- ✅ Clear documentation of testing limitations
- ✅ Easy for future developers to maintain
- ✅ Ready for production release

---

## Technical Constraints & Limitations

### What VS Code API Allows
- ✅ Create decorations with styles
- ✅ Apply decorations to ranges
- ✅ Clear decorations
- ✅ Dispose decorations
- ✅ Listen to editor events
- ✅ Query configuration
- ✅ Execute commands

### What VS Code API Does NOT Allow
- ❌ Query what decorations are applied
- ❌ Inspect decoration styles after creation
- ❌ Verify rendered appearance
- ❌ Get decoration ranges that were set
- ❌ Directly observe mode changes from other extensions
- ❌ Mock/stub the decoration system for unit tests

### Workarounds Implemented
- **Mode detection:** Query ModalEdit context keys
- **Mode changes:** Use cursor movement as proxy
- **Testing:** Test behavior, not visual appearance
- **Verification:** Manual visual testing checklist
- **Debugging:** Extensive logging and debug commands

---

## Next Steps After This Plan

1. **Execute Phase 1** - Debug and identify root cause
2. **Review findings** - Ensure fix approach is correct
3. **Execute Phase 2** - Implement and test bug fix
4. **Execute Phase 3** - Add automated tests
5. **Execute Phase 4** - Create manual testing docs
6. **Execute Phase 5** - Update all documentation
7. **Execute Phase 6** - Final validation
8. **Ready for release!**

---

**Estimated Total Time:** 7-11 hours of focused development

**Priority Order:**
1. Bug fix (CRITICAL)
2. Basic automated tests (HIGH)
3. Manual testing checklist (HIGH)
4. Comprehensive automated tests (MEDIUM)
5. Documentation updates (MEDIUM)

**Can be done in phases:** Yes - bug fix can be done first, tests can be added incrementally.
